## 해시맵 구현 방법

### 분리 체이닝(Seperate Chaining)

위에서 살펴보았던 `해시함수` 와 `모듈러 연산` 을 활용하여 해시 맵의 충돌을 처리하는 방법 중 하나이다. 동일한 해시 인덱스에 여러 키-값 쌍이 저장될 수 있도록 **연결 리스트**를 사용하는 방법이다.

### **작동 방식**

1. **해시 값 계산**
   1. 키를 해시 함수에 통과시켜 해시 값을 계산
2. **인덱스 계산**
   1. 계산된 해시 값을 배열 크기로 나눈 나머지를 구하여 해당 인덱스를 획득
3. **충돌 처리**
   1. 배열의 해당 인덱스에 연결 리스트를 유지하며, 동일한 인덱스에 저장된 모든 키-값 쌍을 저장
   2. 새로운 키-값 쌍이 동일한 인덱스에 삽입될 경우, 연결 리스트에 추가

### **장점**

- **유연성**: 해시 맵의 크기가 고정되지 않으며, 저장할 수 있는 데이터의 양에 제한이 없습니다(연결 리스트의 크기만큼).
- **충돌 처리**: 해시 값이 충돌할 경우에도 기존 데이터를 유지하면서 새로운 데이터를 쉽게 추가할 수 있습니다.

해시 함수와 모듈러 연산을 사용하여 분리 체이닝을 구현하는 방법은 해시 맵에서 충돌을 효과적으로 처리하고, 데이터의 빠른 검색을 가능하게 합니다. 이 방식은 여러 데이터 구조와 알고리즘에서 널리 사용되며, 해시 맵의 기본적인 구현 원리를 이해하는 데 도움이 된다.

### Open Addressing

Open Addressing은 해시 맵에서 충돌을 처리하는 다른 방법이다. 해시 함수가 동일한 인덱스 생성할 때 Open Addressing은 추가적인 데이터 구조를 사용하지 않고 배열 내부에서 빈 슬롯을 찾아 값을 저장하는 방법이다.

### 작동 방식

1. **해시 함수 사용**: 주어진 키에 대해 해시 함수를 사용하여 해시 값을 계산
2. **빈 슬롯 탐색**

   배열에서 해당 인덱스에 값이 존재하면, 다른 인덱스를 탐색하여 빈 슬롯을 찾는다

   - **선형 탐사 (Linear Probing)**
     - 인덱스가 충돌할 경우, 다음 인덱스(현재 인덱스 + 1)를 순차적으로 검사
   - **제곱 탐사 (Quadratic Probing)**
     - 충돌이 발생할 경우, 인덱스를 제곱수만큼 이동하여 검사
     - 예시) 첫 번째 충돌 후에는 1, 4, 9 등으로 이동
   - **해시 함수 재적용 (Double Hashing)**
     - 두 번째 해시 함수를 사용하여 인덱스를 계산
     - 이 값을 더하여 다음 인덱스를 찾음

### 장점

- 메모리 효율성 : 추가적인 메모리 사용 없이 충돌을 처리하기 때문에 메모리 사용이 보다 효율적이다
- 캐시 효율성 : 배열이 연속된 메모리 블록으로 구성되어 있어 캐시 성능이 좋다
