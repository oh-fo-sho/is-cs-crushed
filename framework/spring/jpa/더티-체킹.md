## 더티 체킹

더티 체킹(Dirty Checking)은 JPA가 영속성 컨텍스트(Persistence Context) 내의 엔티티가 변경되었는지 자동으로 감지하고 변경된 내용을 데이터베이스에 반영하는 기능이다. 이 매커니즘은 트랜잭션 커밋 시점에 엔티티의 상태가 데이터베이스와 일치하지 않는 경우 이를 자동으로 업데이트 해주는 역할을 한다

### 원리

1. 엔티티 상태 변화 감지
   1. JPA는 엔티티 객체를 영속성 컨텍스트에 관리하면서 해당 객체의 상태 변화를 감지한다
   2. `persist()` , `merge()` , `remove()` 와 같은 메서드로 엔티티 관리 시, 엔티티의 속성 값이 변경되면 JPA는 이를 변경된 상태로 감지한다
2. 상태 변화 체크
   1. JPA는 엔티티가 영속성 컨텍스트에 있는 동안(`EntityManger` 가 관리하는 동안) 속성 값이 변경되면 이를 자동으로 추적한다
      1. 기존 상태를 스냅샷으로 찍어 보관하다가 비교한다
      2. 내부적으론 equal 비교를 하여 값이 같은지 확인한다
   2. 트랜잭션 커밋 시점에 JPA는 해당 엔티티 객체의 상태가 원본 상태와 비교하여 변경된 값을 데이터베이스에 반영한다
3. 트랜잭션 커밋 시
   1. 트랜잭션이 커밋되면 엔티티의 상태가 원본과 다른 경우 JPA는 자동으로 SQL update 문을 생성하여 데이터베이스에 반영한다
   2. 명시적인 `flush()` 호출 없이도 JPA는 변경 사항을 자동으로 감지하여 데이터베이스에 반영한다

### 주의 사항

1.  영속성 컨텍스트 내에서만 동작
    - 더티 체킹은 영속성 컨텍스트에 관리되는 객체에 한해서 동작
    - 엔티티가 영속성 컨텍스트 바깥에 있다면 더티 체킹은 동작하지 않으므로 수동으로 `merge()` 나 `persist()` 를 호출해야한다
2.  성능
    - 원본 값과 비교하여 상태 변화를 감지하는데 엔티티가 많거나 복잡한 연관 관계를 가질 경우 성능 문제가 나타날 수 있다
    - 큰 객체 그래프를 다룰 때에는 성능에 미치는 영향을 고려해야 함
3.  참조 객체의 변경
    - 객체가 다른 객체를 참조할 경우 참조된 객체의 상태 변경은 더티 체킹을 통해 반영되지 않을 수 있다
    - 이런 경우에도 `merge()` 를 사용하거나 참조 객체도 명시적으로 `flush()` 를 호출해야할 수도 있다
