### 요청-응답의 핵심 개념

1. **요청과 응답의 정의**

   요청은 클라이언트가 서버에 보내는 메시지이고, 응답은 서버가 클라이언트에 되돌려주는 메시지입니다.

   - 요청: 클라이언트가 작업을 요청하며, HTTP 요청이라면 메서드(GET, POST 등), 경로, 헤더, 바디로 구성됩니다.
   - 응답: 서버는 요청의 결과를 클라이언트에 반환하며, 상태 코드(200, 404 등), 헤더, 바디를 포함합니다.

2. **경계의 중요성**

   요청과 응답에서 "어디서 시작하고 어디서 끝나는지"는 서버와 클라이언트 모두에 중요합니다. 이는 프로토콜(예: HTTP, TCP)에서 명확히 정의되며, 이를 기반으로 메시지를 구분하고 처리합니다.

3. **파싱**
   - 서버는 요청을 받아들여 파싱(Parsing)합니다. 이 작업은 단순히 경계를 이해하는 것뿐 아니라, 직렬화된 데이터를 역직렬화하여 프로그래밍 언어에서 사용할 수 있는 구조로 변환합니다.
   - 클라이언트 역시 서버 응답을 처리하려면 역직렬화와 파싱이 필요합니다.
4. **직렬화와 역직렬화**
   - JSON, XML, Protocol Buffers 등의 데이터 포맷은 요청과 응답을 직렬화하여 전달합니다. 직렬화 비용은 선택한 포맷에 따라 달라지며, 이는 성능에 영향을 미칩니다.
   - JSON이 XML보다 가볍고, Protocol Buffers는 JSON보다 더 빠르지만, 사람이 읽기 어려운 단점이 있습니다.
5. **요청 처리와 실행**

   요청 파싱 후, 서버는 요청의 실제 작업(데이터베이스 조회, API 호출 등)을 수행합니다. GET과 같은 단순 조회 요청과 POST와 같은 리소스 생성 요청은 실행 로직이 다릅니다.

---

### 요청-응답 모델의 사례

- **웹(HTTP)**: 클라이언트는 브라우저나 앱으로 HTTP 요청을 보내고, 서버는 HTML, JSON, XML 등을 반환합니다.
- **DNS**: 클라이언트는 도메인의 IP 주소를 요청하고, 서버는 IP를 반환합니다. UDP와 같은 경량 프로토콜을 사용합니다.
- **SQL 쿼리**: 데이터베이스에 명령을 보내고, 결과를 요청합니다.
- **GraphQL**: 여러 요청을 묶어 한 번에 보낼 수 있는 구조를 제공하며, REST의 다중 요청 문제를 해결하려고 합니다.

---

### 직렬화 비용과 최적화

SOAP에서 REST로, REST에서 Protocol Buffers로 전환하는 주요 이유는 파싱 비용과 성능 때문입니다.

- XML은 구조화가 복잡하고 파싱 비용이 높습니다.
- JSON은 사람이 읽기 쉽고 가볍지만, 여전히 파싱에는 시간이 소요됩니다.
- Protocol Buffers는 바이너리 포맷으로 매우 빠르지만, 디버깅이 어렵습니다.

---

### 요청-응답 모델의 개선 방향

1. **파싱 최적화**
   - JSON 대신 Protocol Buffers와 같은 경량 직렬화 도구 사용.
   - 요청의 크기를 줄이고, 불필요한 데이터 전송 방지.
2. **프로토콜의 활용**
   - HTTP/2 및 HTTP/3을 도입하여 멀티플렉싱과 압축을 활용.
   - QUIC와 같은 더 빠른 프로토콜로 전환.
3. **비동기 처리**
   요청과 응답 사이의 병목을 줄이기 위해 비동기 및 스트리밍 처리 방식 도입.
