# 파이프라이닝

파이프라이닝은 **명령어의 여러 단계를 동시에 실행**하여 CPU의 처리 효율을 높이는 기술이다. 해당 개념은 공장에서 작업을 분화하여 여러 작업을 동시에 처리하는 것과 유사하다. CPU에서 파이프라이닝은 명령어를 여러 단계로 나누고, 각 단계를 병렬로 실행하여 성능을 향상 시킨다

# 파이프라이닝의 기본 원리

### 1. 분업화

- 명령어 실행을 여러 단계로 나누고 각 단계를 독립적으로 처리
- 명령어 실행 단계
  - Fetch : 명령어를 메모리에서 가져옴
  - Decode : 명령어 해석
  - Execute : 명령어 실행
  - Memory Access : 메모리에서 데이터를 읽거나 씀
  - Write Back : 연산 결과를 레지스터에 저장

### 2. 병렬 처리

- 각 단계가 동시에 진행되도록 스테이지(Stage)를 병렬화
- 예시
  - Cycle 1: 명령어 1의 Fetch
  - Cycle 2: 명령어 1의 Decode, 명령어 2의 Fetch
  - Cycle 3: 명령어 1의 Execture, 명령어 2의 Decode, 명령어 3의 Fetch

# 파이프라이닝의 장점

### 1. 성능 향상

- 각 단계가 병렬로 실행되므로 CPU의 사용 효율이 증가

### 2. CPU 자원 최적화

- 각 단계가 서로 독립적이므로 자원을 효율적으로 활용 가능

### 3. 단위 작업 시간 단축

- 한 명령어의 실행 시간이 줄어드는 것은 아니지만 연속적인 작업 처리 시간이 줄어 듦

# 파이프라이닝의 한계

## 1. 구조적 충돌(Structural Hazards)

- 여러 명령어가 동일한 하드웨어 자원을 동시에 사용하려고 할 때 발생
- 명령어의 Fetch와 Memory Access가 동일한 메모리 모듈에 접근

## 2. 데이터 충돌(Data Hazards)

- 한 명령어의 결과가 다른 명령어에 필요한 데이터 일 때 발생
- 종류
  - **RAW (Read After Write):** 이전 명령어가 데이터를 기록하기 전에 다른 명령어가 읽으려 할 때
  - **WAR (Write After Read):** 이전 명령어가 데이터를 읽기 전에 다른 명령어가 기록하려 할 때
  - **WAW (Write After Write):** 두 명령어가 동시에 데이터를 기록하려 할 때

## 3. 제어 충돌(Control Hazards)

- 분기(Branch) 명령어로 인해 명령어 흐름이 바뀔 때 발생
- 해결 방법
  - **분기 예측(Branch Prediction):** 분기 결과를 예측하여 파이프라인을 유지
  - **플러시(Flush):** 예측이 틀리면 잘못된 명령어를 제거하고 다시 실행

## 4. 파이프라인 지연(Pipeline Stalls)

- 충돌이나 의존성으로 인해 파이프라인이 멈출 때 발생
- 해결 방법
  - 데이터 전달(Forwarding)
  - 버블(Bubble) 삽입

# 파이프라이닝 성능 평가: 속도 향상 비율(Speedup)

파이프라이닝은 여러 작업을 겹쳐 수행하여 처리 속도를 향상 시키는 것인데, 이를 성능적으로 평가할 때 속도 향상 비율은 파이프 라이닝 도입 전호의 처리 시간을 비교하여 계산한다

## 속도 향상 비율(Speedup) 정의

$Speedup=\frac{비파이프라인-처리-시간}{파이프라인-처리-시간}$

### 비파이프라인 처리 시간

- 작업을 하나씩 순차적으로 처리할 때의 총 소요 시간
- 만약 각 작업이 t만큼 소요되고 작업이 n개 라면
  - $비파이프라인-처리-시간=n\cdot t$

### 파이프라인 처리 시간

- 파이프라인을 통해 여러 작업을 겹쳐 처리할 때의 총 소요 시간
- 파이프라인에서 작업이 완료되는 시간은 초기 단계의 세팅 시간(파이프라인 채우기)과 이후에 각 작업 완료 시간(파이프라인 유지)으로 나뉜다
- m단계의 파이프라인을 n개의 작업에 적용한다면
  - $파이프라인-처리-시간=(m+n-1)\cdot t$

## 실제 상황: 충돌과 지연으로 인한 제한

현실에서는 이론적인 최대 성능에 도달하기 여럽다

### 1. 파이프라인 충돌(Pipeline Hazards)

- 작업 간의 의존성으로 인해 파이프라인이 멈추거나 지연되는 경우
  - 데이터 충돌, 제어 충돌, 구조 충돌 등

### 2. 파이프라인 지연(Latency)

- 각 단계가 작업을 처리하는 데 걸리는 시간이 균일하지 않거나 다음 단계로 넘어가기 전에 대기 시간이 발생할 수 있음

### 3. 오버헤드(Overhead)

- 파이프라인을 초기화하고 유지하는 데 필요한 추가 작업 발생

### 4. 작업 개수의 제한

- 파이프라인의 단계 수보다 작업 수가 적을 경우 파이프라인의 이점이 충분히 발휘되기 어려움

## 실제 속도 향상 비율

$Speedupreal​=\frac{n⋅t}{(m+n-1)\cdot t}​$

만약 작업수가 매우 많다면

$Speedupreal = \frac{n}{n+m-1}\rightarrow m$

작업 수가 매우 많다면 이론적으로 m배에 가까운 속도 향상도 가능

다만 작업 수가 적다면, 파이프라인 채우기와 유지 시간의 비율이 커져 속도 향상이 제한적이다

# 파이프라이닝의 예시

### 비파이프라인 처리 예시

| Task   | Stage 1 | Stage 2 | Stage 3 | Stage 4 |
| ------ | ------- | ------- | ------- | ------- |
| Task 1 | 1초     | 2초     | 3초     | 4초     |
| Task 2 | 5초     | 6초     | 7초     | 8초     |
| Task 3 | 9초     | 10초    | 11초    | 12초    |
| Task 4 | 13초    | 14초    | 15초    | 16초    |
| Task 5 | 17초    | 18초    | 19초    | 20초    |

### 파이프라인 처리 예시

| Time | Stage 1 | Stage 2 | Stage 3 | Stage 4 |
| ---- | ------- | ------- | ------- | ------- |
| 1초  | Task 1  |         |         |         |
| 2초  | Task 2  | Task 1  |         |         |
| 3초  | Task 3  | Task 2  | Task 1  |         |
| 4초  | Task 4  | Task 3  | Task 2  | Task 1  |
| 5초  | Task 5  | Task 4  | Task 3  | Task 2  |
| 6초  |         | Task 5  | Task 4  | Task 3  |
| 7초  |         |         | Task 5  | Task 4  |
| 8초  |         |         |         | Task 5  |

# 파이프라이닝의 현대적 응용

1. **슈퍼스칼라(Superscalar)**
   - 파이프라인을 여러 개 배치하여 동시에 다수의 명령어를 처리
2. **하이퍼스레딩(Hyper-Threading)**
   - CPU 코어가 동시에 여러 스레드를 실행
3. **분기 예측과 동적 스케줄링**
   - 파이프라이닝의 효율성을 높이기 위한 기술
