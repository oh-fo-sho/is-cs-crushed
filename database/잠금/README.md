# Lock

트랜잭션에서 락(Lock)은 데이터의 일관성과 무결성(어느 시점에서든 정확하고 완전하며 일관성이 있다는 것)을 보장하기 위해 사용된다. 여러 트랜잭션에서 동시에 특정 데이터를 변경하려 할 때 발생 가능한 충돌을 방지하며 데이터베이스에서는 잠금을 통해 데이터의 정합성을 유지한다. 잠금에는 다양한 종류와 전략, 레벨 등이 존재하고 이를 통해 트랜잭션 간의 상호작용을 효과적으로 관리할 수 있게 된다

## 잠금 전략

1. 공유 잠금 (Shared Lock)
   1. 읽기 전용 트랜잭션이 데이터를 잠그는 방식
   2. 다른 트랜잭션이 동일 데이터를 읽는 것은 허용 → 쓰기는 불가능
   3. 주로 데이터를 조회할 때 사용
   4. 다수의 트랜잭션이 공유 잠금을 동시에 걸 수 있지만 배타 잠금이 걸릴 때까지 대기해야 한다
2. 배타 잠금 (Exclusive Lock)
   1. 데이터를 변경하는 트랜잭션이 걸 때 사용
   2. 다른 트랜잭션의 읽기 및 쓰기 접근을 모두 차단
   3. 데이터를 수정해야할 때 사용
   4. 하나의 트랜잭션만 잠금을 걸 수 있다

## 잠금 방식

1. 비관적 잠금 (Pessimistic Lock)
   1. 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션이 해당 데이터를 변경하지 못하게 잠금을 거는 방식
   2. 실제 데이터 변경이 발생할 가능성이 높거나 충돌이 자주 발생하는 경우 적합
   3. 데이터베이스 레벨에서 잠금을 적용해 트랜잭션이 종료될 때까지 다른 트랜잭션의 접근 차단
   4. 자원의 경합이 잦은 시스템에서는 안전한 동시성 제어를 가능하게 하지만 대기 시간이 길어져 성능이 떨어질 수 있다
2. 낙관적 잠금 (Optimistic Lock)
   1. 데이터를 수정하는 과정에서 거의 충돌이 없을거라 가정하여 별도의 잠금을 걸지 않고 작업 진행
   2. 트랜잭션이 데이터를 커밋할 경우 데이터가 수정되었는지 확인하는 검증 작업을 함
      1. 수정이 된 경우에만 충돌을 해결하는 방식으로 작동
   3. 버전 번호나 타임스탬프를 사용해 검증
   4. 자원의 경합이 적고 데이터 충돌 가능성이 낮은 환경에서 우수한 성능으로 사용 가능

## 데이터베이스 데드락 (Deadlock)

데드락은 두 개 이상의 트랜잭션이 서로의 자원을 무한히 기다리며 대기하는 상태를 의미한다. 트랜잭션 A가 자원 X를 잠근 이후 자원 Y를 기다리고 트랜잭션 B가 자원 Y를 잠근 이후 X를 기다리는 상황을 생각하면 된다. 이러한 상태를 **교착 상태**라고 부르며 데드락 방지를 위해 몇몇 방법을 사용하기도 한다

- 타임 아웃 설정
  - 트랜잭션의 대기 시간이 길어지면 자동으로 중단하여 데드락 해소
- 순환 대기 방지
  - 자원의 고정된 순서를 지정하여 트랜잭션이 일정한 순서로만 자원을 요청하게 함
- 데드락 탐지
  - 데드락 발생 여부로 주기적으로 점검하여 문제가 발생한 트랜잭션을 강제로 중단 시킴

## 잠금 레벨 (Transaction Isolation Level)

잠금 레벨은 데이터베이스에서 트랜잭션 간의 격리 수준을 결정하는 방법이다. 데이터베이스는 트랜잭션 간의 일관성과 성능을 균형있게 유지하기 위해 격리 수준을 조절하는데 SQL 표준에 따라 4가지의 격리 수준이 있다

1. **READ UNCOMMITTED**
   1. 트랜잭션이 커밋되지 않은 데이터도 다른 트랜잭션이 읽을 수 있다
   2. **Dirty Read** 발생 가능
      1. 다른 트랜잭션의 커밋되지 않은 변경 사항을 읽는 것
   3. 가장 낮은 수준의 격리 수준
   4. 성능은 좋지만 데이터 정합성이 가장 낮다
2. **READ COMMITTED**
   1. 트랜잭션이 커밋된 데이터만 다른 트랜잭션이 읽을 수 있다
   2. Dirty Read는 방지하지만 **Non-repeatable Read** 발생 가능
      1. 같은 트랜잭션에서 두 번 조회할 때 데이터가 변경되는 현상
   3. 대부분의 데이터베이스의 기본 격리 수준이 여기다
3. **REPEATABLE READ**
   1. 트랜잭션이 데이터를 읽고 해당 트랜잭션이 끝날 때까지 다른 트랜잭션이 해당 데이터를 수정할 수 없다
   2. Dirty Read와 Non-repeatable Read를 방지하지만 **Phantom Read** 발생 가능
      1. 트랜잭션 범위 내에서 데이터가 추가되거나 삭제되는 현상
4. **SERIALIZABLE**
   1. 트랜잭션이 순차적으로 실행되는 가장 높은 수준의 격리
   2. 모든 트랜잭션이 일렬로 실행되는 것처럼 동작해 Dirty read, Non-repeatable Read, Phantom Read 모두 방지 가능
   3. 성능은 가장 낮지만 데이터 일관성이 가장 높다
