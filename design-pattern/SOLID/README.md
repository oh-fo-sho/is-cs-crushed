# SOLID

SOLID는 객체지향 설계 원칙을 의미하고 유지보수성과 확정성을 높이는 데에 중요한 다섯가지 원칙을 말한다. 좋은 설계란 변화와 확장에 유연하게 대처하면서 이해하기 쉽고 유지보수가 용이한 구조를 갖춘 설계를 의미한다.

> **좋은 설계가 가지는 특징**

1. 높은 응집도
2. 낮은 결합도
3. 유연한 확장
4. 명확한 책임분리
5. 재사용성
6. 테스트 용이성
7. 직관적, 이해하기 쉬운 구조
8. 변경에 대해 유연함
   >

## 단일 책임 원칙 (Single Reponsibility Principle, SRP)

- 클래스는 단 하나의 책임만 가져야 하며 해당 클래스는 그 책임을 완전히 캡슐화 하여야 한다
- 목적 : 클래스를 작게 유지하여 특정 변경 사항이 필요할 때 해당 책임을 가진 클래스만 수정함으로써 코드의 유지보수를 용이하게 함
  - 담당하고 있는 기능에 대한 변경 혹은 수정이 발생했을 때의 파급효과를 줄이기 위함
  - 단일 책임에 대해 오해할 수 있는데 회원 가입 기능은 회원 기능의 일부

## 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

- 소프트웨어 구성 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있고 수정에는 닫혀 있어야 한다
  - 확장 : 새로운 기능을 추가하는 것
  - 수정 : 클래스의 수정을 최소화 해야함
- 목적 : 기존 코드의 수정 없이 새로운 기능을 추가할 수 있도록 하여 코드 수정에 따른 리스크를 줄인다
- 구현 예 : 인터페이스나 추상 클래스로 정의하고, 이를 구현하여 클래스를 추가하는 방식으로 기능을 추가한다.

## 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

- 어떠한 클래스의 서브 타입은 반드시 기반 타입으로 교체 가능해야 한다
  - 자식 클래스는 부모 클래스의 기능을 대체할 수 있어야 하고 자식 클래스를 부모 클래스처럼 사용할 때 문제가 없어야 한다
- 목적 : 상속 구조에서 자식 클래스가 부모 클래스의 역할을 확실히 대체할 수 잇도록 하여 예측 가능한 코드 작동을 보장하기 위함
  - 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 사용했을 때 코드 이상이 없어야 한다 → 예상대로, 의도대로 작동되어야 한다
  - 부모 클래스와 자식클래스 사이의 행위에 일관성이 있어야 한다
- 구현 예 : 부모 클래스의 메서드 시그니처를 변경하거나 자식 클래스에서 부모 클래스의 기능을 깨뜨리는 방식으로 오버라이딩하지 않도록 주의해야한다.

## 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 하고 필요한 기능만 포함한 작은 인터페이스로 분리해야 한다
  - 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스는 특정 클라이언트에 맞게 세분화 해야 한다.
  - 범용성을 위한 인터페이스를 많이 만드는 것보다 필요한 것들만 정의해서 만들어라
  - 해당 시점에서의 클라이언트는, 나를 사용하는 객체 또한 클라이언트
- 목적 : 불필요한 코드 의존성을 줄여 변경에 대한 영향을 최소화하고 모듈성을 높인다
- 구현 예 : 기능이 다른 메서드를 하나의 큰 인터페이스로 묶지 않고 역할에 따라 작은 인터페이스로 나누어 필요한 것만 구현하게 한다
  - 쓸모 없는 메서드 억지로 구현하게 하지마라

## 의존 역전 원칙 (Dependency Inversion Principle, DIP)

- 고수준 모듈은 저수준 모듈에 의존해서는 안 되고 둘 다 추상화에 의존해야 한다
  - 다른 클래스를 참조할 때, 추상화 된 상위 요소를 참조해야 한다
- 목적 : 구체적인 구현이 아닌 인터페이스에 의존하게 하여 코드의 유연성과 테스트 가능성을 높인다
- 구현 예 : 객체 간의 의존성을 직접 생성하지 않고, 인터페이스나 추상 클래스에 의존하게 하여 의존성을 주입받아 사용해야 한다

SOLID 원칙을 통해 객체지향 설계를 좀 더 유연하고 확장 가능하게 만들어 코드의 가독성과 재사용성을 높이고 효율적인 유지보수를 도모해야 한다
